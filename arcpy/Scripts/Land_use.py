# Land_use.py# Calculates land use within buffer# Must define buffer size in command, e.g. python Land_use.py 100 for 100m buffer file# ------------------------------------------------------------------------------------verbose = 1def file_delete(myDir, basename):    #sys.exit()    pattern = ".*" + basename + ".*"    for root, dirs, files in os.walk(myDir):        for file in files:            if re.search(pattern, file):                #print "remove %s%s" % (myDir,file)                os.remove(myDir + file)import syssys.path.append("C:\Program Files (x86)\ArcGIS\bin")import sys, os, re, time, csv, arcgisscripting string globprint "START ARCGIS"gp = arcgisscripting.create()print "CREATE FieldMappings"fieldmappings = gp.CreateObject("FieldMappings")bs = sys.argv[1]print "BS",bs #bs = "500" # buffer sizeroot  = "S:\\Cabs_R\\Geocoding\\GIS\\Output\\"subdir  = "Buffers\\buff_%s_bySample" % bsworkDir = "%s\\%s" % (root,subdir)#file_delete("%s\\" % workDir,"tmp") # clean dirs for new data#file_delete("%s\\" % workDir,"all") # clean dirs for new data# home_buffershb =  "S:\\Cabs_R\\Geocoding\\GIS\\Buffers\\home_%s.shp" % (bs)fieldmappings.AddTable(hb)lu = "S:\\Cabs_R\\Geocoding\\GIS\\\\Land_use\\land_use.shp"print "LAND USE SIZE",bsfieldmappings.AddTable(lu)#Run one record at a time (note that total N is needed in line 50)appendList = []for i in range(0,6324,1):        if not i%10:            print i        query = '"' + "fid" + '"' + " = " + str(i)        # get single address buffer        curr = "%s\\%s\\home_%s_%dtmp.shp" % (root,subdir,bs,i)        gp.Select_analysis(hb, curr, query)        #run intersect        out = "%s\\%s\\home_%s_%dtmp_LU.shp" %(root,subdir,bs,i)        gp.Intersect_analysis("\"" + lu + "\";" + curr, out, "ALL", "", "INPUT")        #Add land use field        gp.AddField_management("%s\\%s\\home_%s_%dtmp_LU.shp" % (root,subdir,bs,i), "AREAbyLU", "DOUBLE", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")        #calculate area        gp.CalculateField_management("%s\\%s\\home_%s_%dtmp_LU.shp" % (root,subdir,bs,i), "AREAbyLU", "!SHAPE.AREA!", "PYTHON", "")        #create append list        if i>0:            appendList.append("%s\\%s\\home_%s_%dtmp_LU.shp" % (root,subdir,bs,i))                 joinAppendList = ";".join(appendList)#append all to first recordgp.Append_management(joinAppendList, "%s\\%s\\home_%s_0tmp_LU.shp" % (root,subdir,bs), "NO_TEST")#Create csv file of dataset###################################################input = "%s\\%s\\home_%s_0tmp_LU.shp" % (root,subdir,bs)outputpath = "%s\\Buffers\\land_use_output\\LU_home_%s.csv" % (root, bs)fieldmappings = gp.CreateObject("FieldMappings")fieldmappings.AddTable(input)class CursorIterator(object):    def __init__(self, cursor):        self.cursor = cursor        self.cursor.reset()    def next(self):        n = self.cursor.next()        if n is None:            self.cursor.reset()            raise StopIteration        return n    def __iter__(self):        return selfdef get_fieldnames(fields, ignorefields=[]):   ignorefieldsupper = map(string.upper, ignorefields)   fields = CursorIterator(fields)   fields_output = []   for field in fields:       if not field.name.upper() in ignorefieldsupper:           fields_output.append(field.name)   return fields_outputfields = gp.listfields(input)fieldnames = get_fieldnames(fields)print fieldnamesrows = gp.searchcursor(input)rows = CursorIterator(rows)csvseparator = ","output = []output.append(csvseparator.join(fieldnames))for row in rows:   outputrow = []   for fieldname in fieldnames:       outputrow.append(str(row.getvalue(fieldname)))   outputrow = csvseparator.join(outputrow)   output.append(outputrow)#Finally we write the outputlist to the defined outputpath.f = open(outputpath, 'w')f.write('\n'.join(output))f.close()#and delete the temporary shapefilesfiles = glob.glob("S:\\Cabs_R\\Geocoding\\GIS\\Output\\Buffers\\buff_%s_bySample\\*" % bs) for f in files:    os.remove(f)sys.exit()